It looks like you're working to optimize an IoT device, likely an ESP32 camera, to achieve a much higher frame rate. An increase from 0.7 FPS to 30 FPS is a significant goal and will likely require changes to the device-side code.

The performance statistics you've provided (PSRAM, RSSI, Thermal) are typical for an ESP32-based device. The key bottlenecks for low FPS on such devices are usually:

1.  **Image Resolution and Quality:** Higher resolutions (like UXGA, SXGA) and higher JPEG quality settings take much longer for the camera sensor to capture and for the processor to handle.
2.  **Image Processing on Device:** Any image manipulation (resizing, format conversion, etc.) done on the ESP32 before sending will consume CPU cycles.
3.  **Data Transmission Time:** Sending large image data over Wi-Fi takes time and can block the main loop.
4.  **Blocking Code:** Long-running operations or `delay()` calls in the main loop will prevent new frames from being captured quickly.

To help you optimize, I need to look at the code running on your IoT device. Based on your workspace structure, the relevant file is likely CameraWebServer.ino.

Could you please confirm if this is the main file for your ESP32 camera? Once confirmed, I can analyze it and suggest specific optimizations.

In the meantime, here are general areas you'll likely need to adjust in your ESP32's Arduino code:

*   **Reduce Frame Size:**
    *   Look for `sensor_t * s = esp_camera_sensor_get();` and then `s->set_framesize(s, FRAMESIZE_UXGA);` (or similar).
    *   Try changing `FRAMESIZE_UXGA` to something smaller like `FRAMESIZE_SVGA` (800x600), `FRAMESIZE_VGA` (640x480), `FRAMESIZE_CIF` (400x296), or `FRAMESIZE_QVGA` (320x240). Start with QVGA or CIF to see a significant impact.
*   **Lower JPEG Quality:**
    *   Look for `s->set_quality(s, 10);` (or similar, where the value is typically 0-63, lower is better quality but larger size).
    *   Try increasing this value (e.g., to 15-25) to reduce JPEG quality, which makes files smaller and faster to process/send.
*   **Optimize Data Sending:**
    *   Ensure the code that sends the image data (e.g., over HTTP POST) is efficient and non-blocking if possible.
*   **Review Loop Delays:**
    *   Check your main `loop()` function for any `delay()` calls or other blocking operations that could be slowing down the frame capture rate.

Let me know if CameraWebServer.ino is the correct file, and I can provide more targeted advice.


i have `iot-code-main\iot-code-arduino-onefile\iot_camera_stream\camera_manager.cpp` : 
```
/*
 * Camera Manager Implementation
 * Camera initialization, frame capture, and upload functions
 */

#include "camera_manager.h"

// ===========================
// Camera Initialization
// ===========================

void initCamera() {
  Serial.println("Initializing OV5640 camera...");
  
  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer = LEDC_TIMER_0;
  config.pin_d0 = Y2_GPIO_NUM;
  config.pin_d1 = Y3_GPIO_NUM;
  config.pin_d2 = Y4_GPIO_NUM;
  config.pin_d3 = Y5_GPIO_NUM;
  config.pin_d4 = Y6_GPIO_NUM;
  config.pin_d5 = Y7_GPIO_NUM;
  config.pin_d6 = Y8_GPIO_NUM;
  config.pin_d7 = Y9_GPIO_NUM;
  config.pin_xclk = XCLK_GPIO_NUM;
  config.pin_pclk = PCLK_GPIO_NUM;
  config.pin_vsync = VSYNC_GPIO_NUM;
  config.pin_href = HREF_GPIO_NUM;
  config.pin_sccb_sda = SIOD_GPIO_NUM;
  config.pin_sccb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn = PWDN_GPIO_NUM;
  config.pin_reset = RESET_GPIO_NUM;
  config.xclk_freq_hz = XCLK_FREQ_HZ;
  config.frame_size = FRAMESIZE_VGA;
  config.pixel_format = PIXFORMAT_JPEG;
  config.grab_mode = CAMERA_GRAB_WHEN_EMPTY;
  config.jpeg_quality = JPEG_QUALITY_INITIAL;
  config.fb_count = FB_COUNT_DRAM;

  // Optimize for PSRAM
  if (psramFound()) {
    config.fb_location = CAMERA_FB_IN_PSRAM;
    config.jpeg_quality = JPEG_QUALITY_PSRAM;
    config.fb_count = FB_COUNT_PSRAM;
    Serial.println("PSRAM found - using optimized settings");
  } else {
    config.fb_location = CAMERA_FB_IN_DRAM;
    config.jpeg_quality = JPEG_QUALITY_DRAM;
    Serial.println("No PSRAM - using conservative settings");
  }

  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed: 0x%x\n", err);
    delay(5000);
    ESP.restart();
    return;
  }

  Serial.println("Camera initialized successfully!");

  // Configure sensor
  sensor_t* s = esp_camera_sensor_get();
  if (s) {
    // Basic settings
    s->set_framesize(s, FRAMESIZE_VGA);
    s->set_brightness(s, 0);
    s->set_contrast(s, 0);
    s->set_saturation(s, 0);
    s->set_whitebal(s, 1);
    s->set_awb_gain(s, 1);
    s->set_exposure_ctrl(s, 1);
    s->set_gain_ctrl(s, 1);
    
    // Upgrade to 720p if PSRAM available
    if (psramFound()) {
      // delay(2000);
      // Serial.println("Upgrading to 720p...");
      // s->set_framesize(s, FRAMESIZE_HD);  // Enable 720p for PSRAM systems
      s->set_quality(s, JPEG_QUALITY_PSRAM);
      // s->set_contrast(s, 1);
      // s->set_gainceiling(s, (gainceiling_t)4);
      // s->set_bpc(s, 1);
      // s->set_wpc(s, 1);
      // s->set_raw_gma(s, 1);
      // s->set_lenc(s, 1);
      // s->set_dcw(s, 1);
      // s->set_aec_value(s, 400);
      // Serial.println("Camera upgraded to 720p");
    }
  }
}

// ===========================
// Frame Capture and Upload
// ===========================

void captureAndSendFrame() {
  frameCount++;
  yield();
  
  // Check thermal conditions before capture
  checkThermalConditions();
  
  if (WiFi.status() != WL_CONNECTED) {
    if (frameCount % WIFI_STATUS_LOG_INTERVAL == 0) {
      Serial.println("WiFi not connected - skipping frame");
    }
    dropCount++;
    return;
  }
  
  unsigned long captureStart = millis();
  camera_fb_t* fb = esp_camera_fb_get();
  if (!fb) {
    Serial.println("Camera capture failed");
    dropCount++;
    return;
  }
  
  unsigned long captureTime = millis() - captureStart;
  unsigned long sendStart = millis();
  bool success = sendFrameWithRetry(fb);
  unsigned long sendTime = millis() - sendStart;
  
  if (success) {
    successCount++;
    totalBytes += fb->len;
    if (frameCount % FRAME_LOG_INTERVAL == 0) {
      Serial.printf("‚úì Frame #%lu: %lu bytes, Cap: %lums, Send: %lums", 
                    frameCount, fb->len, captureTime, sendTime);
      if (thermalThrottling) {
        Serial.printf(" [THERMAL: %.1f¬∞C]", currentTemperature);
      }
      Serial.println();
    }
  } else {
    dropCount++;
    if (frameCount % FAILURE_LOG_INTERVAL == 0) {
      Serial.printf("‚úó Frame #%lu failed (%lu bytes)", frameCount, fb->len);
      if (thermalThrottling) {
        Serial.printf(" [THERMAL: %.1f¬∞C]", currentTemperature);
      }
      Serial.println();
    }
  }

  esp_camera_fb_return(fb);
}

// ===========================
// Enhanced Frame Upload with Retry Logic
// ===========================

bool sendFrameWithRetry(camera_fb_t* fb) {
  if (!fb || fb->len == 0) return false;
  if (WiFi.status() != WL_CONNECTED) return false;
  
  // Try primary server first with reduced timeout
  for (int retry = 0; retry < MAX_SERVER_RETRIES; retry++) {
    int timeout = HTTP_TIMEOUT_MS - (retry * SERVER_TIMEOUT_REDUCTION_STEP);
    if (timeout < 2000) timeout = 2000; // Minimum 2 seconds
    
    if (frameCount % FRAME_LOG_INTERVAL == 0) {
      Serial.printf("Attempting upload to primary server (retry %d/%d, timeout: %dms)\n", 
                    retry + 1, MAX_SERVER_RETRIES, timeout);
    }
    
    if (sendFrameToURL(fb, SERVER_URL, timeout)) {
      if (frameCount % FRAME_LOG_INTERVAL == 0) {
        Serial.println("‚úÖ Primary server upload successful");
      }
      return true;
    }
    
    delay(500 * (retry + 1)); // Progressive delay: 500ms, 1s, 1.5s
  }
  
  // If primary server fails and fallback is enabled
  if (USE_FALLBACK_ON_ERROR) {
    if (frameCount % FAILURE_LOG_INTERVAL == 0) {
      Serial.println("Primary server failed, trying fallback server...");
    }
    
    if (sendFrameToURL(fb, FALLBACK_SERVER_URL, 3000)) {
      if (frameCount % FAILURE_LOG_INTERVAL == 0) {
        Serial.println("‚úÖ Fallback server upload successful");
      }
      return true;
    }
  }
  
  // Log failure details periodically
  if (frameCount % FAILURE_LOG_INTERVAL == 0) {
    Serial.printf("‚ùå All upload attempts failed for frame #%lu\n", frameCount);
  }
  
  return false;
}

bool sendFrameToURL(camera_fb_t* fb, const char* url, int timeout_ms) {
  if (!fb || fb->len == 0 || !url) return false;
  if (WiFi.status() != WL_CONNECTED) return false;

  http.begin(client, url);
  http.addHeader("X-API-Key", API_KEY);
  http.setTimeout(timeout_ms);
  
  String boundary = "----ESP32CAMBoundary";
  String header = "--" + boundary + "\r\n"
                  "Content-Disposition: form-data; name=\"image\"; filename=\"frame.jpg\"\r\n"
                  "Content-Type: image/jpeg\r\n\r\n";
  String footer = "\r\n--" + boundary + "--\r\n";
  
  size_t totalLength = header.length() + fb->len + footer.length();
  
  // Always try the complete payload method first for simplicity
  uint8_t* payload = (uint8_t*)malloc(totalLength);
  if (payload) {
    memcpy(payload, header.c_str(), header.length());
    memcpy(payload + header.length(), fb->buf, fb->len);
    memcpy(payload + header.length() + fb->len, footer.c_str(), footer.length());
    
    http.addHeader("Content-Type", "multipart/form-data; boundary=" + boundary);
    int httpCode = http.POST(payload, totalLength);
    free(payload);
    
    // Only log errors periodically to avoid spam
    if (httpCode != 200 && frameCount % FAILURE_LOG_INTERVAL == 0) {
      Serial.printf("HTTP Error: %d for URL: %s\n", httpCode, url);
      if (httpCode > 0) {
        String response = http.getString();
        Serial.printf("Error response: %s\n", response.substring(0, 100).c_str());
      } else {
        Serial.printf("Request failed: %s\n", http.errorToString(httpCode).c_str());
      }
    }
    
    http.end();
    return (httpCode == 200);
  } else {
    // Memory allocation failed
    if (frameCount % FAILURE_LOG_INTERVAL == 0) {
      Serial.printf("Memory allocation failed for frame upload (size: %d)\n", totalLength);
    }
    http.end();
    return false;
  }
}

// Legacy function - now uses the retry logic
bool sendFrameToServer(camera_fb_t* fb) {
  return sendFrameWithRetry(fb);
}

// ===========================
// Thermal Management Functions
// ===========================

float getESP32Temperature() {
  // ESP32-S3 has internal temperature sensor
  // Note: This is an approximation, actual implementation may vary
  
  // Method 1: Use ESP32 internal temperature sensor (if available)
  #ifdef SOC_TEMP_SENSOR_SUPPORTED
    // Use built-in temperature sensor API if available
    float temp = temperatureRead();
    return temp;
  #endif
  
  // Method 2: Estimate based on CPU frequency and load
  // Higher CPU usage and frequency = higher temperature
  uint32_t cpuFreq = getCpuFrequencyMhz();
  uint32_t freeHeap = ESP.getFreeHeap();
  uint32_t totalHeap = ESP.getHeapSize();
  float heapUsage = (float)(totalHeap - freeHeap) / totalHeap;
  
  // Rough temperature estimation formula (more conservative)
  // Base temperature + CPU frequency factor + load factor
  float estimatedTemp = 30.0 + (cpuFreq - 160) * 0.12 + heapUsage * 8.0;
  
  // Add some variance based on frame processing
  if (successCount > 0) {
    float processingLoad = (float)frameCount / (millis() / 1000.0);
    estimatedTemp += processingLoad * 0.3;
  }
  
  // Account for ambient and startup warming
  unsigned long runtime = millis();
  if (runtime < 60000) { // First minute
    estimatedTemp += 5.0; // Assume higher initial temperature
  } else if (runtime < 300000) { // First 5 minutes
    estimatedTemp += 2.0; // Gradual warm-up
  }
  
  return estimatedTemp;
}

float getAveragedTemperature() {
  // Add current temperature to history
  temperatureHistory[temperatureHistoryIndex] = getESP32Temperature();
  temperatureHistoryIndex = (temperatureHistoryIndex + 1) % TEMPERATURE_AVERAGING_SAMPLES;
  
  // Calculate average
  float sum = 0;
  for (int i = 0; i < TEMPERATURE_AVERAGING_SAMPLES; i++) {
    sum += temperatureHistory[i];
  }
  
  return sum / TEMPERATURE_AVERAGING_SAMPLES;
}

void checkThermalConditions() {
  if (!ENABLE_THERMAL_MANAGEMENT) return;
  
  unsigned long currentTime = millis();
  if (currentTime - lastTemperatureCheck < TEMPERATURE_CHECK_INTERVAL_MS) {
    return;
  }
  
  // Get averaged temperature for more stable readings
  currentTemperature = getAveragedTemperature();
  lastTemperatureCheck = currentTime;
  
  // Handle startup cooling phase
  if (AGGRESSIVE_COOLING_AT_STARTUP && startupCoolingPhase) {
    if (currentTime < startupPhaseEndTime) {
      // Keep conservative settings during startup
      if (!thermalThrottling) {
        Serial.println("üöÄ Startup phase: Using conservative settings for stable quality");
        thermalThrottling = true;
        thermalAdjustedFPS = TARGET_FPS * 0.8;
        thermalAdjustedQuality = JPEG_QUALITY_PSRAM + 1;
        applyThermalOptimizations(currentTemperature);
      }
      return;
    } else {
      // End startup phase
      startupCoolingPhase = false;
      Serial.println("‚úÖ Startup phase complete - switching to normal thermal management");
    }
  }
  
  // Log temperature periodically
  if (frameCount % (FRAME_LOG_INTERVAL * 4) == 0) {
    Serial.printf("üå°Ô∏è Temperature: %.1f¬∞C", currentTemperature);
    if (thermalThrottling) {
      Serial.printf(" (OPTIMIZED)");
    }
    if (proactiveCoolingActive) {
      Serial.printf(" (PROACTIVE)");
    }
    Serial.println();
  }
  
  // Apply thermal management with hysteresis to prevent oscillation
  if (currentTemperature >= TEMPERATURE_THRESHOLD_CRITICAL) {
    if (!thermalThrottling) {
      Serial.printf("üî• CRITICAL TEMPERATURE: %.1f¬∞C - Applying aggressive cooling\n", currentTemperature);
      thermalThrottling = true;
      proactiveCoolingActive = false;
      
      // Aggressive thermal management
      thermalAdjustedFPS = TARGET_FPS * 0.6; // More aggressive FPS reduction
      thermalAdjustedQuality = JPEG_QUALITY_PSRAM + 3; // Lower compression for quality
      
      applyThermalOptimizations(currentTemperature);
      
      // Force cooling delay
      delay(COOLING_DELAY_MS);
    }
  }
  else if (currentTemperature >= TEMPERATURE_THRESHOLD_HIGH) {
    if (!thermalThrottling) {
      Serial.printf("üî• HIGH TEMPERATURE: %.1f¬∞C - Applying thermal optimizations\n", currentTemperature);
      thermalThrottling = true;
      proactiveCoolingActive = false;
    }
    
    // Moderate thermal management
    thermalAdjustedFPS = TARGET_FPS * THERMAL_FPS_REDUCTION_FACTOR;
    thermalAdjustedQuality = JPEG_QUALITY_PSRAM + THERMAL_QUALITY_ADJUSTMENT;
    
    applyThermalOptimizations(currentTemperature);
  }
  else if (PROACTIVE_COOLING_ENABLED && currentTemperature >= TEMPERATURE_THRESHOLD_WARM) {
    if (!proactiveCoolingActive && !thermalThrottling) {
      Serial.printf("‚ö†Ô∏è WARM TEMPERATURE: %.1f¬∞C - Applying proactive optimizations\n", currentTemperature);
      proactiveCoolingActive = true;
      
      // Light proactive optimizations
      thermalAdjustedFPS = TARGET_FPS * 0.9; // Slight FPS reduction
      thermalAdjustedQuality = JPEG_QUALITY_PSRAM; // Keep quality but optimize sensors
      
      applyProactiveOptimizations();
    }
  }
  else if (currentTemperature < TEMPERATURE_THRESHOLD_WARM - 3.0) { // Hysteresis
    if (thermalThrottling || proactiveCoolingActive) {
      Serial.printf("‚ùÑÔ∏è Temperature normalized: %.1f¬∞C - Restoring optimal settings\n", currentTemperature);
      thermalThrottling = false;
      proactiveCoolingActive = false;
      resetCameraToOptimalSettings();
    }
  }
}

void applyThermalOptimizations(float temperature) {
  sensor_t* s = esp_camera_sensor_get();
  if (!s) return;
  
  Serial.printf("üîß Applying thermal optimizations for %.1f¬∞C\n", temperature);
  
  // Reduce sensor gain to minimize noise and heat generation
  s->set_gain_ctrl(s, 1);
  if (temperature >= TEMPERATURE_THRESHOLD_CRITICAL) {
    s->set_gainceiling(s, (gainceiling_t)1); // Lowest gain ceiling for critical temp
  } else {
    s->set_gainceiling(s, (gainceiling_t)2); // Lower gain ceiling
  }
  
  // Optimize exposure for heat conditions
  s->set_exposure_ctrl(s, 1);
  if (temperature >= TEMPERATURE_THRESHOLD_CRITICAL) {
    s->set_aec_value(s, 250); // Lower exposure for critical temp
  } else {
    s->set_aec_value(s, 300); // Slightly lower exposure to reduce sensor heat
  }
  
  // Improve white balance for thermal stability
  s->set_whitebal(s, 1);
  s->set_awb_gain(s, 1);
  
  // Adjust image processing for better quality under heat
  s->set_bpc(s, 1);      // Black pixel correction
  s->set_wpc(s, 1);      // White pixel correction
  s->set_raw_gma(s, 1);  // Gamma correction
  s->set_lenc(s, 1);     // Lens correction
  
  // Enhanced denoise settings for high temperature
  s->set_denoise(s, 1);  // Enable denoise if available
  
  // Brightness and contrast adjustments for heat
  s->set_brightness(s, 0);
  s->set_contrast(s, 2);  // Slightly higher contrast to compensate for quality loss
  s->set_saturation(s, 1); // Maintain good saturation
  
  // Adjust quality dynamically
  s->set_quality(s, thermalAdjustedQuality);
  
  // If temperature is very high, temporarily reduce resolution
  if (temperature >= TEMPERATURE_THRESHOLD_CRITICAL) {
    Serial.println("üìâ Reducing resolution to VGA for cooling");
    s->set_framesize(s, FRAMESIZE_VGA);
  } else if (temperature >= TEMPERATURE_THRESHOLD_HIGH) {
    // Keep current resolution but optimize settings
    Serial.println("‚öôÔ∏è Optimizing settings for high temperature");
  }
}

void applyProactiveOptimizations() {
  sensor_t* s = esp_camera_sensor_get();
  if (!s) return;
  
  Serial.println("üõ°Ô∏è Applying proactive thermal optimizations");
  
  // Light optimizations to prevent overheating
  s->set_gain_ctrl(s, 1);
  s->set_gainceiling(s, (gainceiling_t)3); // Moderate gain ceiling
  
  s->set_exposure_ctrl(s, 1);
  s->set_aec_value(s, 350); // Slightly reduced exposure
  
  // Ensure all quality enhancements are active
  s->set_bpc(s, 1);
  s->set_wpc(s, 1);
  s->set_raw_gma(s, 1);
  s->set_lenc(s, 1);
  s->set_denoise(s, 1);
  
  // Maintain good image quality
  s->set_brightness(s, 0);
  s->set_contrast(s, 1);
  s->set_saturation(s, 0);
  s->set_quality(s, thermalAdjustedQuality);
}

void resetCameraToOptimalSettings() {
  sensor_t* s = esp_camera_sensor_get();
  if (!s) return;
  
  Serial.println("üîÑ Resetting camera to optimal settings");
  
  // Restore optimal settings
  thermalAdjustedFPS = TARGET_FPS;
  thermalAdjustedQuality = JPEG_QUALITY_PSRAM;
  
  // Restore framesize to 720p if PSRAM available
  if (psramFound()) {
    s->set_framesize(s, FRAMESIZE_HD);
  } else {
    s->set_framesize(s, FRAMESIZE_VGA);
  }
  
  // Restore optimal quality
  s->set_quality(s, JPEG_QUALITY_PSRAM);
  
  // Restore optimal sensor settings
  s->set_gainceiling(s, (gainceiling_t)4);
  s->set_aec_value(s, 400);
  s->set_brightness(s, 0);
  s->set_contrast(s, 1);
  s->set_saturation(s, 0);
  
  // Restore image processing
  s->set_bpc(s, 1);
  s->set_wpc(s, 1);
  s->set_raw_gma(s, 1);
  s->set_lenc(s, 1);
  s->set_dcw(s, 1);
}
```

i have `iot-code-main\iot-code-arduino-onefile\iot_camera_stream\camera_manager.h` : 
```
/*
 * Camera Manager Header
 * Camera initialization, frame capture, and upload functions
 */

#ifndef CAMERA_MANAGER_H
#define CAMERA_MANAGER_H

#include "esp_camera.h"
#include <WiFi.h>
#include <HTTPClient.h>
#include "config.h"
#include "globals.h"

// ===========================
// Camera Management Functions
// ===========================

/**
 * Initialize OV5640 camera with optimal settings for ESP32-S3
 * Automatically configures for PSRAM if available
 */
void initCamera();

/**
 * Capture frame and send to server with error handling
 * Updates global performance counters
 */
void captureAndSendFrame();

// ===========================
// Frame Upload Functions
// ===========================

/**
 * Send frame to server with retry logic and fallback
 * @param fb Camera frame buffer
 * @return true if upload successful
 */
bool sendFrameWithRetry(camera_fb_t* fb);

/**
 * Send frame to specific URL with timeout
 * @param fb Camera frame buffer
 * @param url Target server URL
 * @param timeout_ms HTTP timeout in milliseconds
 * @return true if upload successful
 */
bool sendFrameToURL(camera_fb_t* fb, const char* url, int timeout_ms);

/**
 * Legacy function - now uses retry logic
 * @param fb Camera frame buffer
 * @return true if upload successful
 */
bool sendFrameToServer(camera_fb_t* fb);

// ===========================
// Thermal Management Functions
// ===========================

/**
 * Get ESP32-S3 internal temperature
 * @return Temperature in Celsius
 */
float getESP32Temperature();

/**
 * Get averaged temperature for stable readings
 * @return Averaged temperature in Celsius
 */
float getAveragedTemperature();

/**
 * Check temperature and adjust camera settings for optimal image quality
 */
void checkThermalConditions();

/**
 * Apply thermal optimizations to camera sensor
 * @param temperature Current temperature
 */
void applyThermalOptimizations(float temperature);

/**
 * Apply proactive optimizations to prevent overheating
 */
void applyProactiveOptimizations();

/**
 * Reset camera sensor to optimal settings when temperature is normal
 */
void resetCameraToOptimalSettings();

#endif // CAMERA_MANAGER_H
```

i have `iot-code-main\iot-code-arduino-onefile\iot_camera_stream\config.h` : 
```
/*
 * Configuration Header File
 * Contains ONLY configuration constants, pin definitions, and compile-time settings
 * No function declarations or global variables here
 */

#ifndef CONFIG_H
#define CONFIG_H

// ===========================
// Network Configuration
// ===========================
#define WIFI_SSID "BIZNET357"
#define WIFI_PASSWORD "ivan4321"

// ===========================
// Server Configuration
// ===========================
#define SERVER_URL "http://203.175.11.145:9005/api/v1/stream/stream"
#define REGISTER_URL "http://203.175.11.145:9005/api/v1/devices/register"
#define HEARTBEAT_URL "http://203.175.11.145:9005/api/v1/devices/heartbeat"
#define API_KEY "dev-api-key-change-in-production"

// Fallback/Alternative Servers
#define FALLBACK_SERVER_URL "http://httpbin.org/post"
#define LOCAL_SERVER_URL "http://192.168.18.100:3000/upload"

// ===========================
// Device Configuration
// ===========================
#define DEVICE_ID "ESP32-CAM-001"
#define DEVICE_NAME "Camera #1"

// ===========================
// ESP32-S3 Camera Pin Configuration for OV5640
// ===========================
#define PWDN_GPIO_NUM  -1
#define RESET_GPIO_NUM -1
#define XCLK_GPIO_NUM  15
#define SIOD_GPIO_NUM  4
#define SIOC_GPIO_NUM  5

#define Y9_GPIO_NUM    16
#define Y8_GPIO_NUM    17
#define Y7_GPIO_NUM    18
#define Y6_GPIO_NUM    12
#define Y5_GPIO_NUM    10
#define Y4_GPIO_NUM    8
#define Y3_GPIO_NUM    9
#define Y2_GPIO_NUM    11
#define VSYNC_GPIO_NUM 6
#define HREF_GPIO_NUM  7
#define PCLK_GPIO_NUM  13

// ===========================
// Performance Configuration
// ===========================
#define TARGET_FPS 30
#define FRAME_INTERVAL_MS (1000 / TARGET_FPS)
#define HEARTBEAT_INTERVAL_MS 30000
#define STATS_INTERVAL_MS 5000
#define WIFI_CHECK_INTERVAL_MS 15000
#define WIFI_RECONNECT_INTERVAL_MS 60000

// ===========================
// Thermal Management Configuration
// ===========================
#define ENABLE_THERMAL_MANAGEMENT true
#define TEMPERATURE_CHECK_INTERVAL_MS 1500    // Check temperature every 1.5 seconds (more frequent)
#define TEMPERATURE_THRESHOLD_WARM 60.0       // Start light optimizations (¬∞C)
#define TEMPERATURE_THRESHOLD_HIGH 68.0       // High temperature threshold (¬∞C) - lowered
#define TEMPERATURE_THRESHOLD_CRITICAL 75.0   // Critical temperature threshold (¬∞C) - lowered
#define COOLING_DELAY_MS 3000                 // Shorter cooling delay for responsiveness
#define THERMAL_FPS_REDUCTION_FACTOR 0.75     // Reduce FPS to 75% when hot (less aggressive)
#define THERMAL_QUALITY_ADJUSTMENT 1          // Smaller quality adjustment for better consistency
#define PROACTIVE_COOLING_ENABLED true        // Enable proactive cooling before overheating
#define TEMPERATURE_AVERAGING_SAMPLES 3       // Average temperature over multiple readings
#define AGGRESSIVE_COOLING_AT_STARTUP true    // Apply conservative settings initially

// ===========================
// Camera Configuration
// ===========================
#define INITIAL_CPU_FREQ_MHZ 160
#define MAX_CPU_FREQ_MHZ 240
#define XCLK_FREQ_HZ 20000000

// Quality settings
#define JPEG_QUALITY_PSRAM 6
#define JPEG_QUALITY_DRAM 12
#define JPEG_QUALITY_INITIAL 10

// Buffer settings
#define FB_COUNT_PSRAM 2
#define FB_COUNT_DRAM 1

// ===========================
// Network Settings
// ===========================
#define HTTP_TIMEOUT_MS 5000
#define WIFI_RETRY_COUNT 30
#define CHUNK_SIZE 1024
#define USE_FALLBACK_ON_ERROR true
#define MAX_SERVER_RETRIES 3
#define SERVER_TIMEOUT_REDUCTION_STEP 2000

// ===========================
// Debug Configuration
// ===========================
#define SERIAL_BAUD_RATE 921600
#define FRAME_LOG_INTERVAL 10
#define FAILURE_LOG_INTERVAL 5
#define WIFI_STATUS_LOG_INTERVAL 50

// Enhanced debugging options
#define DEBUG_HTTP_RESPONSES true
#define DEBUG_PAYLOAD_SIZE true
#define TEST_SERVER_CONNECTIVITY true

// ===========================
// Memory Optimization
// ===========================
#define GC_INTERVAL_FRAMES 100
#define WATCHDOG_FEED_DELAY_MS 1

#endif // CONFIG_H
```

i have `iot-code-main\iot-code-arduino-onefile\iot_camera_stream\globals.h` : 
```
/*
 * Global Variables and External Declarations
 * Contains all global variables, extern declarations, and shared objects
 */

#ifndef GLOBALS_H
#define GLOBALS_H

#include <WiFi.h>
#include <HTTPClient.h>
#include "esp_camera.h"
#include "config.h"

// ===========================
// Global HTTP Objects
// ===========================
extern HTTPClient http;
extern WiFiClient client;

// ===========================
// Timing Variables
// ===========================
extern unsigned long lastFrameTime;
extern unsigned long lastHeartbeatTime;
extern unsigned long lastStatsTime;
extern unsigned long streamStartTime;

// ===========================
// Performance Tracking Variables
// ===========================
extern uint32_t frameCount;
extern uint32_t successCount;
extern uint32_t dropCount;
extern uint32_t totalBytes;
extern bool deviceRegistered;

// ===========================
// WiFi Management Variables
// ===========================
extern unsigned long lastWiFiCheck;
extern unsigned long lastReconnectAttempt;

// ===========================
// Thermal Management Variables
// ===========================
extern unsigned long lastTemperatureCheck;
extern float currentTemperature;
extern float temperatureHistory[TEMPERATURE_AVERAGING_SAMPLES]; // Temperature averaging array
extern int temperatureHistoryIndex;
extern bool thermalThrottling;
extern float thermalAdjustedFPS;
extern int thermalAdjustedQuality;
extern bool proactiveCoolingActive;         // New: Proactive cooling state
extern bool startupCoolingPhase;           // New: Startup conservative phase
extern unsigned long startupPhaseEndTime;  // New: When to end startup phase

// ===========================
// Performance Monitoring Function
// ===========================
void printPerformanceStats();

#endif // GLOBALS_H
```

i have `iot-code-main\iot-code-arduino-onefile\iot_camera_stream\iot_camera_stream.ino` :
```
/*
 * ESP32-S3 OV5640 Camera High-Performance Video Streaming
 * MAXIMUM QUALITY OPTIMIZATION FOR 720p @ 30 FPS
 * 
 * Features:
 * - 720p (1280x720) resolution at 30 FPS target
 * - JPEG Quality optimization with PSRAM support
 * - Triple buffering with PSRAM optimization
 * - Real-time performance monitoring
 * - Modular architecture for maintainability
 * - Advanced retry logic and fallback servers
 * 
 * Hardware: ESP32-S3 + OV5640 Camera Module + PSRAM
 * 
 * File Structure:
 * - config.h: Configuration constants and pin definitions
 * - globals.h: Global variables and external declarations
 * - wifi_manager.h/.cpp: WiFi and network management
 * - camera_manager.h/.cpp: Camera operations and frame handling
 * - iot_camera_stream.ino: Main program logic and performance monitoring
 */

#include "config.h"
#include "globals.h"
#include "wifi_manager.h"
#include "camera_manager.h"

// ===========================
// Global Variable Definitions
// ===========================

// HTTP Objects
HTTPClient http;
WiFiClient client;

// Timing variables
unsigned long lastFrameTime = 0;
unsigned long lastHeartbeatTime = 0;
unsigned long lastStatsTime = 0;
unsigned long streamStartTime = 0;

// Performance tracking
uint32_t frameCount = 0;
uint32_t successCount = 0;
uint32_t dropCount = 0;
uint32_t totalBytes = 0;
bool deviceRegistered = false;

// WiFi management
unsigned long lastWiFiCheck = 0;
unsigned long lastReconnectAttempt = 0;

// Thermal Management Variables
unsigned long lastTemperatureCheck = 0;
float currentTemperature = 25.0;  // Initialize to room temperature
float temperatureHistory[TEMPERATURE_AVERAGING_SAMPLES] = {25.0}; // Initialize all to room temp
int temperatureHistoryIndex = 0;
bool thermalThrottling = false;
float thermalAdjustedFPS = TARGET_FPS;
int thermalAdjustedQuality = JPEG_QUALITY_PSRAM;
bool proactiveCoolingActive = false;
bool startupCoolingPhase = AGGRESSIVE_COOLING_AT_STARTUP;
unsigned long startupPhaseEndTime = 0;

void setup() {
  // Initialize serial communication
  Serial.begin(SERIAL_BAUD_RATE);
  delay(2000);
  
  // System information
  Serial.println("\nESP32-S3 OV5640 Camera Stream Initializing...");
  Serial.println("System Information:");
  Serial.printf("- Chip: %s Rev %d\n", ESP.getChipModel(), ESP.getChipRevision());
  Serial.printf("- Flash: %d bytes\n", ESP.getFlashChipSize());
  Serial.printf("- Free Heap: %lu bytes\n", ESP.getFreeHeap());

  // CPU frequency optimization
  setCpuFrequencyMhz(INITIAL_CPU_FREQ_MHZ);
  Serial.printf("- CPU Frequency: %d MHz\n", getCpuFrequencyMhz());
  
  // PSRAM check
  if (psramFound()) {
    Serial.printf("- PSRAM: %d bytes\n", ESP.getPsramSize());
  } else {
    Serial.println("- PSRAM: Not found - using conservative settings");
  }

  // Initialize thermal management
  if (AGGRESSIVE_COOLING_AT_STARTUP) {
    startupPhaseEndTime = millis() + 120000; // 2 minutes of conservative settings
    Serial.println("üöÄ Startup cooling phase: 2 minutes of conservative settings for image stability");
  }
  
  // Initialize temperature history
  for (int i = 0; i < TEMPERATURE_AVERAGING_SAMPLES; i++) {
    temperatureHistory[i] = 25.0; // Room temperature baseline
  }

  // Initialize subsystems
  Serial.println("\nInitializing WiFi...");
  initWiFi();
  
  Serial.println("\nInitializing camera...");
  delay(3000); // Stability delay
  initCamera();
  
  // Performance boost
  delay(2000);
  setCpuFrequencyMhz(MAX_CPU_FREQ_MHZ);
  Serial.printf("CPU boosted to: %d MHz\n", getCpuFrequencyMhz());
  
  // Register device if WiFi connected
  if (WiFi.status() == WL_CONNECTED) {
    // Test server connectivity first
    if (testServerConnectivity()) {
      Serial.println("Testing simple HTTP POST...");
      testSimpleUpload();
      registerDevice();
    } else {
      Serial.println("‚ö†Ô∏è Server connectivity test failed - will retry during streaming");
    }
  }
  
  Serial.println("Setup complete. Starting video stream...");
  streamStartTime = millis();
  lastFrameTime = streamStartTime;
  lastHeartbeatTime = streamStartTime;
  lastStatsTime = streamStartTime;
  lastWiFiCheck = streamStartTime;
}

void loop() {
  unsigned long currentTime = millis();
  
  // Calculate dynamic frame interval based on thermal conditions
  unsigned long frameInterval = (1000.0 / thermalAdjustedFPS);
  
  // Frame capture and transmission with thermal adjustment
  if (currentTime - lastFrameTime >= frameInterval) {
    captureAndSendFrame();
    lastFrameTime = currentTime;
  }
  
  // Heartbeat transmission
  if (currentTime - lastHeartbeatTime >= HEARTBEAT_INTERVAL_MS) {
    sendHeartbeat();
    lastHeartbeatTime = currentTime;
  }
  
  // Performance statistics
  if (currentTime - lastStatsTime >= STATS_INTERVAL_MS) {
    printPerformanceStats();
    lastStatsTime = currentTime;
  }
  
  // WiFi connection monitoring
  checkWiFiConnection();
  
  // Memory management and watchdog
  if (frameCount % GC_INTERVAL_FRAMES == 0) {
    ESP.getFreeHeap(); // Trigger garbage collection
  }
  
  delay(WATCHDOG_FEED_DELAY_MS); // Feed watchdog
}

// ===========================
// Performance Monitoring
// ===========================

void printPerformanceStats() {
  unsigned long currentTime = millis();
  unsigned long runTime = currentTime - streamStartTime;
  
  if (runTime == 0) return;
  
  float actualFPS = (float)frameCount * 1000.0 / runTime;
  float successRate = frameCount > 0 ? (float)successCount * 100.0 / frameCount : 0;
  float avgFrameSize = successCount > 0 ? (float)totalBytes / successCount : 0;
  float throughputKBps = (float)totalBytes / (runTime / 1000.0) / 1024.0;
  
  Serial.println("\n" + String("=").substring(0, 50));
  Serial.println("üìä PERFORMANCE STATISTICS");
  Serial.println(String("=").substring(0, 50));
  Serial.printf("Runtime: %lu.%03lu seconds\n", runTime/1000, runTime%1000);
  Serial.printf("FPS: %.2f (Target: %d", actualFPS, TARGET_FPS);
  if (thermalAdjustedFPS != TARGET_FPS) {
    Serial.printf(", Thermal: %.1f", thermalAdjustedFPS);
  }
  Serial.printf(")\n");
  Serial.printf("Frames: Total=%lu, Success=%lu, Dropped=%lu\n", frameCount, successCount, dropCount);
  Serial.printf("Success Rate: %.1f%%\n", successRate);
  Serial.printf("Frame Size: %.1f KB avg\n", avgFrameSize/1024.0);
  Serial.printf("Throughput: %.1f KB/s\n", throughputKBps);
  Serial.printf("Memory: Free=%lu", ESP.getFreeHeap());
  if (psramFound()) {
    Serial.printf(", PSRAM=%lu", ESP.getFreePsram());
  }
  Serial.printf(" bytes\n");
  Serial.printf("Network: RSSI=%d dBm, CPU=%d MHz\n", WiFi.RSSI(), getCpuFrequencyMhz());
  Serial.printf("Thermal: %.1f¬∞C", currentTemperature);
  if (thermalThrottling) {
    Serial.printf(" (OPTIMIZED)");
  } else if (proactiveCoolingActive) {
    Serial.printf(" (PROACTIVE)");
  } else if (startupCoolingPhase) {
    Serial.printf(" (STARTUP)");
  }
  Serial.println();
  
  // Performance rating
  if (actualFPS >= 25.0) {
    Serial.println("üü¢ Performance: EXCELLENT");
  } else if (actualFPS >= 15.0) {
    Serial.println("üü° Performance: GOOD");
  } else if (actualFPS >= 8.0) {
    Serial.println("üü† Performance: MODERATE");
  } else {
    Serial.println("üî¥ Performance: NEEDS OPTIMIZATION");
  }
  
  Serial.println(String("=").substring(0, 50) + "\n");
}

```

i have `iot-code-main\iot-code-arduino-onefile\iot_camera_stream\wifi_manager.h` : 
```
/*
 * WiFi Manager Header
 * WiFi connection, management, and network testing functions
 */

#ifndef WIFI_MANAGER_H
#define WIFI_MANAGER_H

#include <WiFi.h>
#include <HTTPClient.h>
#include "config.h"
#include "globals.h"

// ===========================
// WiFi Management Functions
// ===========================

/**
 * Initialize WiFi connection with network scanning and diagnostics
 */
void initWiFi();

/**
 * Convert WiFi status code to human-readable string
 * @param status WiFi status code
 * @return String representation of status
 */
String getWiFiStatusString(wl_status_t status);

/**
 * Check and maintain WiFi connection, attempt reconnection if needed
 */
void checkWiFiConnection();

// ===========================
// Network Testing Functions
// ===========================

/**
 * Test basic server connectivity with GET request
 * @return true if server is reachable
 */
bool testServerConnectivity();

/**
 * Test simple HTTP POST with JSON payload
 * @return true if POST request succeeds
 */
bool testSimpleUpload();

// ===========================
// Device Management Functions
// ===========================

/**
 * Register device with backend server
 * @return true if registration successful
 */
bool registerDevice();

/**
 * Send heartbeat to maintain device status
 * @return true if heartbeat sent successfully
 */
bool sendHeartbeat();

#endif // WIFI_MANAGER_H
```

i have `iot-code-main\iot-code-arduino-onefile\iot_camera_stream\wifi_manager.cpp` : 
```
/*
 * WiFi Manager Implementation
 * WiFi connection, management, and network testing functions
 */

#include "wifi_manager.h"

// ===========================
// WiFi Management Functions
// ===========================

void initWiFi() {
  Serial.println("Initializing WiFi...");
  
  WiFi.disconnect(true);
  delay(1000);
  
  WiFi.mode(WIFI_STA);
  WiFi.setSleep(false);
  
  // Quick network scan for diagnostics
  Serial.println("Scanning for WiFi networks...");
  int networkCount = WiFi.scanNetworks();
  Serial.printf("Found %d networks\n", networkCount);
  
  bool targetFound = false;
  for (int i = 0; i < networkCount; i++) {
    String foundSSID = WiFi.SSID(i);
    if (foundSSID == WIFI_SSID) {
      targetFound = true;
      int32_t rssi = WiFi.RSSI(i);
      Serial.printf("‚úì Target network '%s' found (RSSI: %d dBm)\n", WIFI_SSID, rssi);
      if (rssi < -80) Serial.println("‚ö†Ô∏è Weak signal strength");
      break;
    }
  }
  
  if (!targetFound) {
    Serial.printf("‚ùå Network '%s' not found!\n", WIFI_SSID);
    return;
  }
  
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  
  int retryCount = 0;
  while (WiFi.status() != WL_CONNECTED && retryCount < WIFI_RETRY_COUNT) {
    delay(1000);
    if (++retryCount % 5 == 0) {
      Serial.printf("WiFi connecting... %d/%d\n", retryCount, WIFI_RETRY_COUNT);
      if (retryCount == 15) {
        WiFi.disconnect();
        delay(1000);
        WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
      }
    }
    yield();
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("‚úÖ WiFi connected!");
    Serial.printf("IP: %s | RSSI: %d dBm\n", WiFi.localIP().toString().c_str(), WiFi.RSSI());
    WiFi.setAutoReconnect(true);
  } else {
    Serial.printf("‚ùå WiFi failed after %d attempts\n", retryCount);
  }
}

String getWiFiStatusString(wl_status_t status) {
  switch (status) {
    case WL_CONNECTED: return "Connected";
    case WL_NO_SSID_AVAIL: return "No SSID";
    case WL_CONNECT_FAILED: return "Failed";
    case WL_CONNECTION_LOST: return "Lost";
    case WL_DISCONNECTED: return "Disconnected";
    default: return "Unknown";
  }
}

void checkWiFiConnection() {
  unsigned long currentTime = millis();
  
  if (currentTime - lastWiFiCheck >= WIFI_CHECK_INTERVAL_MS) {
    if (WiFi.status() != WL_CONNECTED) {
      if (currentTime - lastReconnectAttempt >= WIFI_RECONNECT_INTERVAL_MS) {
        Serial.printf("WiFi disconnected (%s) - reconnecting...\n", 
                      getWiFiStatusString(WiFi.status()).c_str());
        initWiFi();
        lastReconnectAttempt = currentTime;
      }
    } else {
      lastReconnectAttempt = 0; // Reset reconnect timer
    }
    lastWiFiCheck = currentTime;
  }
}

// ===========================
// Network Testing Functions
// ===========================

bool testServerConnectivity() {
  Serial.println("Testing server connectivity...");
  
  http.begin(client, SERVER_URL);
  http.addHeader("X-API-Key", API_KEY);
  http.setTimeout(3000);
  
  int httpCode = http.GET();
  
  Serial.printf("Server connectivity test result: %d\n", httpCode);
  if (httpCode > 0) {
    String response = http.getString();
    Serial.printf("Server response: %s\n", response.substring(0, 100).c_str());
    
    if (httpCode == 200 || httpCode == 404 || httpCode == 405) {
      Serial.println("‚úÖ Server is reachable (endpoint may need configuration)");
      http.end();
      return true;
    } else {
      Serial.printf("‚ö†Ô∏è Server returned code: %d\n", httpCode);
    }
  } else {
    Serial.printf("‚ùå Server connection failed: %s\n", http.errorToString(httpCode).c_str());
  }
  
  http.end();
  return false;
}

bool testSimpleUpload() {
  Serial.println("Testing simple HTTP POST...");
  
  http.begin(client, SERVER_URL);
  http.addHeader("X-API-Key", API_KEY);
  http.addHeader("Content-Type", "application/json");
  http.setTimeout(HTTP_TIMEOUT_MS);
  
  String testPayload = "{\"test\":\"ESP32-camera-connectivity\",\"timestamp\":" + String(millis()) + "}";
  
  int httpCode = http.POST(testPayload);
  Serial.printf("Simple POST test result: %d\n", httpCode);
  
  if (httpCode > 0) {
    String response = http.getString();
    Serial.printf("Simple POST response: %s\n", response.substring(0, 200).c_str());
    http.end();
    return (httpCode == 200 || httpCode == 400);
  } else {
    Serial.printf("Simple POST failed: %s\n", http.errorToString(httpCode).c_str());
    http.end();
    return false;
  }
}

// ===========================
// Device Management Functions
// ===========================

bool registerDevice() {
  Serial.println("Registering device...");
  
  http.begin(client, REGISTER_URL);
  http.addHeader("Content-Type", "application/json");
  http.addHeader("X-API-Key", API_KEY);
  http.setTimeout(HTTP_TIMEOUT_MS);
  
  String payload = "{\"deviceId\":\"" + String(DEVICE_ID) + 
                  "\",\"deviceName\":\"" + String(DEVICE_NAME) + 
                  "\",\"deviceType\":\"camera\",\"ipAddress\":\"" + 
                  WiFi.localIP().toString() + 
                  "\",\"capabilities\":[\"streaming\",\"recording\",\"capture\"]}";
  
  int httpCode = http.POST(payload);
  bool success = (httpCode == 200);
  
  if (success) {
    Serial.println("Device registered successfully!");
    deviceRegistered = true;
  } else {
    Serial.printf("Registration failed: %d\n", httpCode);
  }
  
  http.end();
  return success;
}

bool sendHeartbeat() {
  if (!deviceRegistered) {
    return registerDevice();
  }
  
  http.begin(client, HEARTBEAT_URL);
  http.addHeader("Content-Type", "application/json");
  http.addHeader("X-API-Key", API_KEY);
  http.setTimeout(HTTP_TIMEOUT_MS);
  
  String payload = "{\"deviceId\":\"" + String(DEVICE_ID) + 
                  "\",\"uptime\":" + String(millis()) + 
                  ",\"freeHeap\":" + String(ESP.getFreeHeap()) + 
                  ",\"wifiRssi\":" + String(WiFi.RSSI()) + 
                  ",\"status\":\"online\"}";
  
  int httpCode = http.POST(payload);
  bool success = (httpCode == 200);
  
  if (success) {
    Serial.println("Heartbeat sent");
  } else {
    Serial.printf("Heartbeat failed: %d\n", httpCode);
    deviceRegistered = false;
  }
  
  http.end();
  return success;
}
```





please fix:
```
=


=
üìä PERFORMANCE STATISTICS
=
Runtime: 149.359 seconds
FPS: 0.70 (Target: 30)
Frames: Total=105, Success=105, Dropped=0
Success Rate: 100.0%
Frame Size: 21.1 KB avg
Throughput: 14.8 KB/s
Memory: Free=246744, PSRAM=8248776 bytes
Network: RSSI=-52 dBm, CPU=240 MHz
Thermal: 51.3¬∞C
üî¥ Performance: NEEDS OPTIMIZATION
=

```

i need 30 fps, it only gives that many.

i am using esp32 s3 with ov5640
but i still need to be able to run image recognition model for face recognition.
is there a way so i can just stream my data. and the backend will make the image better. so the image processing will not be in the esp32 s3.
but will be in my backend?
what if i still want 960x540 10fps
but i want it to make the very heavy loading on the backend.
this is my backend for reference:
```

  // Stream endpoint with face recognition
  app.post('/api/v1/stream/stream', streamUpload.single('image'), async (req, res) => {
    if (!req.file) {
      console.log('[Stream API] No image provided in request');
      return res.status(400).json({ error: 'No image provided' });
    }

    const timestamp = Date.now();
    const deviceId = req.body.deviceId || 'unknown_device';
    const filename = `${deviceId}_${timestamp}.jpg`;
    const filePath = path.join(dataDir, filename);

    console.log(`[Stream API] Received frame from device: ${deviceId}, timestamp: ${timestamp}`);

    try {
      // Save the image to the data directory
      await fsp.writeFile(filePath, req.file.buffer);
      console.log('[Stream API] Frame saved:', filePath);

      // Perform face recognition
      console.log('[Stream API] Initiating face recognition for frame:', filename);
      const recognition = await dataStore.performFaceRecognition(req.file.buffer);
      console.log('[Stream API] Face recognition result for frame ', filename, ':', JSON.stringify(recognition));
      
      // Broadcast to WebSocket clients
      const wsMessage = {
        type: 'new_frame',
        deviceId,
        timestamp,
        filename,
        url: `/data/${filename}`,
        recognition: {
          status: recognition.status,
          recognizedAs: recognition.recognizedAs,
          confidence: recognition.confidence, // Make sure to include confidence if available
          error: recognition.error // Include error details if any
        }
      };
      
      console.log('[Stream API] Broadcasting WebSocket message:', JSON.stringify(wsMessage));
      wss.clients.forEach(client => {
        if (client.readyState === WebSocket.OPEN) {
          client.send(JSON.stringify(wsMessage));
        }
      });

      res.json({ 
        message: 'Frame received', 
        filename: filename,
        recognitionStatus: recognition.status, 
        recognizedAs: recognition.recognizedAs,
        confidence: recognition.confidence,
        error: recognition.error
      });

    } catch (err) {
      console.error('[Stream API] Error processing frame:', err.message, err.stack);
      res.status(500).json({ error: 'Failed to process frame', details: err.message });
    }
  });
```